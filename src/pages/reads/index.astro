---
import BaseHead from '../../components/BaseHead.astro';
import Footer from '../../components/Footer.astro';
import Header from '../../components/Header.astro';
import { SITE_TITLE } from '../../consts';
import { books } from '../../booksData';

const statusLabels = {
	'reading': 'Currently Reading',
	'finished': 'Finished',
	'want-to-read': 'Want to Read'
};
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={`Reads | ${SITE_TITLE}`} description="What I've read" />
	</head>
	<body>
		<Header />
		<main class="mx-auto w-full lg:w-5/8 px-6 py-10 space-y-8">
			<div class="space-y-2">
				<h1 class="text-3xl font-bold">My Library</h1>
				<p class="text-muted-foreground">Books I'm reading, have read, and want to read</p>
			</div>

			<!-- Filters -->
			<div class="flex flex-wrap gap-4 items-center p-4 rounded-lg border bg-card">
				<div class="flex items-center gap-2">
					<label for="status-filter" class="text-sm font-medium">Status:</label>
					<select id="status-filter" class="px-3 py-1.5 text-sm rounded-md border bg-background">
						<option value="all">All</option>
						<option value="reading">Currently Reading</option>
						<option value="finished">Finished</option>
						<option value="want-to-read">Want to Read</option>
					</select>
				</div>

				<div class="flex items-center gap-2">
					<label for="year-filter" class="text-sm font-medium">Year:</label>
					<select id="year-filter" class="px-3 py-1.5 text-sm rounded-md border bg-background">
						<option value="all">All Years</option>
					</select>
				</div>

				<div class="flex items-center gap-2">
					<label for="rating-filter" class="text-sm font-medium">Rating:</label>
					<select id="rating-filter" class="px-3 py-1.5 text-sm rounded-md border bg-background">
						<option value="all">All Ratings</option>
						<option value="4.5-5">4.5+ Stars</option>
						<option value="4-4.5">4.0-4.4 Stars</option>
						<option value="3.5-4">3.5-3.9 Stars</option>
						<option value="3-3.5">3.0-3.4 Stars</option>
						<option value="0-3">Below 3 Stars</option>
					</select>
				</div>

				<div class="flex items-center gap-2">
					<label for="group-by" class="text-sm font-medium">Group by:</label>
					<select id="group-by" class="px-3 py-1.5 text-sm rounded-md border bg-background">
						<option value="none">None</option>
						<option value="status" selected>Status</option>
						<option value="year">Year</option>
					</select>
				</div>
			</div>

			<!-- Books Container -->
			<div id="books-container" class="space-y-12">
				<!-- Books will be rendered here by JavaScript -->
			</div>

			<!-- Empty State -->
			<div id="empty-state" class="hidden text-center py-12 text-muted-foreground">
				<p>No books found matching your filters.</p>
			</div>
		</main>
		<Footer />

		<script define:vars={{ books, statusLabels }}>
			// Get all filter elements
			const statusFilter = document.getElementById('status-filter');
			const yearFilter = document.getElementById('year-filter');
			const ratingFilter = document.getElementById('rating-filter');
			const groupBySelect = document.getElementById('group-by');
			const booksContainer = document.getElementById('books-container');
			const emptyState = document.getElementById('empty-state');

			// Populate year filter
			function populateYearFilter() {
				const years = new Set();
				books.forEach(book => {
					if (book.dateFinished) {
						years.add(new Date(book.dateFinished).getFullYear());
					} else if (book.dateStarted) {
						years.add(new Date(book.dateStarted).getFullYear());
					}
				});

				const sortedYears = Array.from(years).sort((a, b) => b - a);
				sortedYears.forEach(year => {
					const option = document.createElement('option');
					option.value = year;
					option.textContent = year;
					yearFilter.appendChild(option);
				});
			}

			// Filter books based on current filter values
			function filterBooks() {
				const statusValue = statusFilter.value;
				const yearValue = yearFilter.value;
				const ratingValue = ratingFilter.value;

				return books.filter(book => {
					// Status filter
					if (statusValue !== 'all' && book.status !== statusValue) {
						return false;
					}

					// Year filter
					if (yearValue !== 'all') {
						let bookYear = null;
						if (book.dateFinished) {
							bookYear = new Date(book.dateFinished).getFullYear();
						} else if (book.dateStarted) {
							bookYear = new Date(book.dateStarted).getFullYear();
						}

						if (bookYear === null || bookYear.toString() !== yearValue) {
							return false;
						}
					}

					// Rating filter
					if (ratingValue !== 'all' && book.rating) {
						const [minRating, maxRating] = ratingValue.split('-').map(parseFloat);
						if (maxRating === 5 && book.rating < minRating) {
							return false;
						} else if (maxRating !== 5 && (book.rating < minRating || book.rating >= maxRating)) {
							return false;
						}
					} else if (ratingValue !== 'all' && !book.rating) {
						return false;
					}

					return true;
				});
			}

			// Group books by status or year
			function groupBooks(filteredBooks, groupBy) {
				if (groupBy === 'none') {
					return { 'All Books': filteredBooks };
				}

				const groups = {};

				if (groupBy === 'status') {
					filteredBooks.forEach(book => {
						const label = statusLabels[book.status] || book.status;
						if (!groups[label]) {
							groups[label] = [];
						}
						groups[label].push(book);
					});
				} else if (groupBy === 'year') {
					filteredBooks.forEach(book => {
						let year = 'No date';
						if (book.dateFinished) {
							year = new Date(book.dateFinished).getFullYear().toString();
						} else if (book.dateStarted) {
							year = new Date(book.dateStarted).getFullYear().toString();
						}
						if (!groups[year]) {
							groups[year] = [];
						}
						groups[year].push(book);
					});

					// Sort groups by year (descending)
					const sortedGroups = {};
					Object.keys(groups).sort((a, b) => {
						if (a === 'No date') return 1;
						if (b === 'No date') return -1;
						return parseInt(b) - parseInt(a);
					}).forEach(key => {
						sortedGroups[key] = groups[key];
					});
					return sortedGroups;
				}

				return groups;
			}

			// Generate placeholder SVG cover with title and author
			function generatePlaceholderCover(title, author) {
				// Truncate title and author if too long
				const truncateText = (text, maxLength) => {
					return text.length > maxLength ? text.substring(0, maxLength - 3) + '...' : text;
				};

				const displayTitle = truncateText(title, 30);
				const displayAuthor = truncateText(author, 25);

				// Split title into lines if it's long
				const titleLines = [];
				const words = displayTitle.split(' ');
				let currentLine = '';

				words.forEach((word, index) => {
					const testLine = currentLine + (currentLine ? ' ' : '') + word;
					if (testLine.length > 15 && currentLine) {
						titleLines.push(currentLine);
						currentLine = word;
					} else {
						currentLine = testLine;
					}
				});
				if (currentLine) titleLines.push(currentLine);

				// Limit to 3 lines
				const finalTitleLines = titleLines.slice(0, 3);

				const svg = `
					<svg width="300" height="450" xmlns="http://www.w3.org/2000/svg">
						<rect width="300" height="450" fill="#FFFBEB"/>

						<!-- Decorative border -->
						<rect x="15" y="15" width="270" height="420" fill="none" stroke="rgba(0,0,0,0.15)" stroke-width="1"/>
						<rect x="20" y="20" width="260" height="410" fill="none" stroke="rgba(0,0,0,0.1)" stroke-width="1"/>

						<!-- Title -->
						<text x="150" y="${120 + (finalTitleLines.length === 1 ? 20 : 0)}" font-family="Georgia, serif" font-size="28" font-weight="bold" fill="#1a1a1a" text-anchor="middle">
							${finalTitleLines.map((line, i) => `<tspan x="150" dy="${i === 0 ? 0 : 32}">${line}</tspan>`).join('')}
						</text>

						<!-- Decorative line -->
						<line x1="60" y1="${200 + (finalTitleLines.length - 1) * 15}" x2="240" y2="${200 + (finalTitleLines.length - 1) * 15}" stroke="rgba(0,0,0,0.2)" stroke-width="1"/>

						<!-- Author -->
						<text x="150" y="${240 + (finalTitleLines.length - 1) * 15}" font-family="Georgia, serif" font-size="18" fill="#4a4a4a" text-anchor="middle">
							${displayAuthor}
						</text>
					</svg>
				`;

				return 'data:image/svg+xml;base64,' + btoa(svg);
			}

			// Render star rating with decimal support using SVG
			function renderStars(rating) {
				if (!rating) return '';
				let starsHTML = '<div class="flex gap-0.5 items-center">';

				for (let i = 1; i <= 5; i++) {
					const fillPercentage = Math.min(Math.max(rating - (i - 1), 0), 1) * 100;
					const starId = `star-gradient-${Math.random().toString(36).substr(2, 9)}`;

					starsHTML += `
						<svg class="w-4 h-4" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
							<defs>
								<linearGradient id="${starId}">
									<stop offset="${fillPercentage}%" stop-color="rgb(234 179 8)" />
									<stop offset="${fillPercentage}%" stop-color="rgb(229 231 235)" />
								</linearGradient>
							</defs>
							<path fill="url(#${starId})" d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
						</svg>
					`;
				}

				starsHTML += `<span class="ml-1 text-xs text-muted-foreground">${rating.toFixed(1)}</span></div>`;
				return starsHTML;
			}

			// Format date
			function formatDate(date) {
				if (!date) return '';
				const d = new Date(date);
				return d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
			}

			// Render books
			function renderBooks() {
				const filteredBooks = filterBooks();
				const groupBy = groupBySelect.value;
				const groupedBooks = groupBooks(filteredBooks, groupBy);

				booksContainer.innerHTML = '';

				if (filteredBooks.length === 0) {
					emptyState.classList.remove('hidden');
					return;
				}

				emptyState.classList.add('hidden');

				Object.entries(groupedBooks).forEach(([groupName, booksInGroup]) => {
					// Create group section
					const section = document.createElement('section');
					section.className = 'space-y-6';

					// Add group heading if grouped
					if (groupBy !== 'none') {
						const heading = document.createElement('h2');
						heading.className = 'text-2xl font-semibold';
						heading.textContent = groupName;
						section.appendChild(heading);
					}

					// Create grid
					const grid = document.createElement('div');
					grid.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-6';

					booksInGroup.forEach(book => {
						const bookCard = document.createElement('div');
						bookCard.className = 'group space-y-3';

						// Cover image
						const coverLink = document.createElement('a');
						coverLink.className = 'block aspect-[2/3] rounded-lg overflow-hidden bg-muted border shadow-sm hover:shadow-xl transition-all duration-300 hover:-translate-y-2';

						const coverImg = document.createElement('img');
						const placeholderSvg = generatePlaceholderCover(book.title, book.author);

						// Start with placeholder
						coverImg.src = placeholderSvg;
						coverImg.alt = `${book.title} cover`;
						coverImg.className = 'w-full h-full object-cover transition-transform duration-300 group-hover:scale-105';
						coverImg.loading = 'lazy';

						// Try to load the actual cover
						const actualCover = new Image();
						actualCover.onload = function() {
							coverImg.src = book.coverUrl;
						};
						actualCover.onerror = function() {
							// Keep the placeholder if the actual cover fails to load
							coverImg.src = placeholderSvg;
						};
						actualCover.src = book.coverUrl;

						coverLink.appendChild(coverImg);
						bookCard.appendChild(coverLink);

						// Book info
						const info = document.createElement('div');
						info.className = 'space-y-1';

						// Title
						const title = document.createElement('h3');
						title.className = 'font-medium text-sm leading-tight line-clamp-2';
						title.textContent = book.title;
						info.appendChild(title);

						// Author
						const author = document.createElement('p');
						author.className = 'text-xs text-muted-foreground line-clamp-1';
						author.textContent = book.author;
						info.appendChild(author);

						// Rating
						if (book.rating) {
							const rating = document.createElement('div');
							rating.className = 'text-sm';
							rating.innerHTML = renderStars(book.rating);
							info.appendChild(rating);
						}

						// Status badge (only show if not grouped by status)
						if (groupBy !== 'status') {
							const statusBadge = document.createElement('span');
							statusBadge.className = 'inline-block text-xs px-2 py-0.5 rounded-full bg-muted';
							statusBadge.textContent = statusLabels[book.status];
							info.appendChild(statusBadge);
						}

						// Date (finished or started)
						if (groupBy !== 'year') {
							if (book.dateFinished) {
								const date = document.createElement('p');
								date.className = 'text-xs text-muted-foreground';
								date.textContent = 'Finished: ' + formatDate(book.dateFinished);
								info.appendChild(date);
							} else if (book.dateStarted) {
								const date = document.createElement('p');
								date.className = 'text-xs text-muted-foreground';
								date.textContent = 'Started: ' + formatDate(book.dateStarted);
								info.appendChild(date);
							}
						}

						bookCard.appendChild(info);
						grid.appendChild(bookCard);
					});

					section.appendChild(grid);
					booksContainer.appendChild(section);
				});
			}

			// Initialize
			populateYearFilter();
			renderBooks();

			// Add event listeners
			statusFilter.addEventListener('change', renderBooks);
			yearFilter.addEventListener('change', renderBooks);
			ratingFilter.addEventListener('change', renderBooks);
			groupBySelect.addEventListener('change', renderBooks);
		</script>
	</body>
</html>
